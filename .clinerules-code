# Code Mode Rules

## Expected Response

- Provide complete implementation code without omission.
- Include TypeScript type definitions.
- Implement according to security best practices.
- Propose UI/UX considering responsive design.
- Detailed explanation in English.
- Component design considering testability.
- Pass lefthook pre-commit hooks when committing via git.
- Don't forget to update the codebase documentation to match changes.

## Application Coding Conventions

- Comply with existing ESLint and Prettier settings.
- Use Composition API for component design.
- Include appropriate comments for functions and components.
- Manage loading states using Next.js SuspenseBoundary.
- Separate logic from components and extract into utility functions.
- Use functional components to increase logic reusability.
- Utilize slots (children prop) to increase component reusability.
- Testable component design.
- Separation of side effects.

### Naming Rules

- Directories: kebab-case
- Files: kebab-case
- Component Names: PascalCase
- Variable Names: camelCase
- Constant Names: snake_case
- React hook names: camelCase
- CSS class names: Use Tailwind CSS class names

### Next.js Specific Conventions

- Await `params` to avoid "params should be awaited" error. Example: `const { id } = await params;`
- Accept `params` as a Promise. Example: `{ params: Promise<{ id: string }> }`

## Component Implementation Conventions

### Conventions by Component Type

#### Buttons

- Implement based on shadcn/ui button component.
- Name click handlers in the format `handle[Action]Click`.
- Implement visual feedback for disabled state (`btn-disabled`).
- Unify loading state representation (`loading` attribute).
- Appropriately use styles according to button type (`btn-primary`, `btn-ghost`, etc.).
- Implement Type definitions with TypeScript to ensure type safety of click events.

#### Modals

- Implement based on shadcn/ui modal component.
- Control visibility with `isVisible` property.
- Implement focus trap.
- Support keyboard operation (Escape).

#### Lists/Tables

- Implement based on shadcn/ui table component.
- Implement pagination.
- Unified implementation of sort/filter functions.
- Unified display of empty state (`empty-state`).
- Display of loading state (`loading`).
- Implement custom error handling functions for appropriate error processing.

### Error Handling

- Error handling using Next.js ErrorBoundary.
  - Appropriate error handling with try-catch.
- Display user-friendly error messages.
- Log error states.
  - Record error logs using Pino.

## Test Implementation Conventions

- Write test cases using the AAA pattern.

### Component Tests

#### File Configuration

- Maintain the same directory structure as components.
- File name is `[ComponentName].spec.ts`.
- Group test cases by function.

#### Test Case Design

- Verification of component mount state.
- Verification of Props, events, and slots operation.
- Verification of display/hide by conditional branching.
- Test user interactions.
- Error state handling.
- Avoid verification of internal implementation such as `wrapper.vm`.

#### Test Data

- Data generation using Factory pattern.
- Preparation of realistic test data.
- Boundary value and abnormal value testing.

#### Test Data Generation and Mocking

- Ensure visibility of test data generation tailored to individual test cases.
- Avoid batched test data generation or mocking (keep it local).

### Repository Tests

#### File Configuration

- Maintain the same directory structure as repositories.
- File name is `[RepositoryName].spec.ts`.
- Group by CRUD operation.

#### Test Case Design

- Verification of basic CRUD operations.
- Comprehensive testing of error cases.
- Data integrity check.
- Verification of queries including relations.

#### Test Data Management

- Creation and deletion of test data.
- Reliable execution of cleanup processing.

### Test Data Generation and Mocking Conventions

#### Clarification of Data Scope

- Global data (base data generated by Factory) should be placed immediately before the top `describe` block.
- Test case specific data is defined within each test case.
- Data used only in a specific test group is defined within that `describe` block.

#### Implementation of Mock Processing

- Define mock functions with `vi.hoisted`.

```ts
const { fetchFromRepository, validateUtil } = vi.hoisted(() => ({
  fetchFromRepository: vi.fn(),
  validateUtil: vi.fn()
}))
```

#### Repository Mock

- Always return in the format `{ data, error }`.
- Explicitly set `error: null` if there is no error.
- Use a string or `{ message: string }` for errors.

```ts
// Success pattern
repositoryMock.mockResolvedValue({ data: result, error: null })

// Error pattern
repositoryMock.mockResolvedValue({
  data: null,
  error: { message: 'Failed to fetch data' }
})
```

#### Utils Mock

- Return value format is free according to function implementation.
- Return values following type definitions.

```ts
// Success pattern
validateUtil.mockResolvedValue(true)
formatUtil.mockReturnValue('formatted text')
calculateUtil.mockReturnValue(100)

// Error pattern
validateUtil.mockRejectedValue(new Error('Validation error'))
```

## Confirmation After Code Changes

1. Check build: `npm run build`

2. Run unit tests for changed files

- Test file naming convention: `[FileName].spec.ts`
- Test file placement: Corresponding directory under `src/spec/`
  - Components: `src/spec/components/`
  - Utils: `src/spec/utils/`
  - Repositories: `src/spec/repositories/`

Example:

### Run specific test file

```bash
npm run test:unit src/spec/utils/example.spec.ts
```

### Run all tests in specific directory

```bash
npm run test:unit src/spec/utils/
```

Note:

- Run tests corresponding to the changed source code.
- If tests fail continuously, report the problem to the user and ask for instructions.
