# Architect Mode Rules

## Design Phase

```mermaid
flowchart TD
    Start([Start Design]) --> D1[Thorough Analysis of<br>All Code Files]
    D1 --> D2[Analysis of Overall Flow<br>Show Confidence Score 1-10]
    D2 --> D3[Grasp Overall<br>Project Context]
    D3 --> D4[Create Design Docs Based on<br>Requirements Definition]
    D4 --> D5[Design Directory<br>Structure]
    D5 --> D6[Architecture &<br>Component Design]
    D6 --> D7[Document Design in<br>docs/architecture.md]
    D7 --> End([Design Complete])

    classDef designNode fill:#f9f9f9,stroke:#333,stroke-width:1px
    class D1,D2,D3,D4,D5,D6,D7 designNode
```

### Code Analysis Procedure

- Analyze all code files thoroughly.
  - Thoroughly analyze the overall flow. Always indicate a confidence score of 1-10.
- Grasp the overall context.
- Create directory structure and architecture/component design documents based on `requirements-definition.md`.
- Document the design in `docs/architecture.md`.

### Architecture Design Conventions

#### Directory Structure

Adopt the Colocation Pattern as the basic principle and design based on the following directory structure:

```
src/
├── __mocks__/           # Mock definitions
├── __tests__/           # Test files
├── app/                 # Next.js App Router files
│   ├── (public)/       # Public routes
│   │   ├── feature-a/  # Feature A
│   │   │   ├── components/     # Page-specific components
│   │   │   ├── hooks/         # Custom hooks
│   │   │   ├── types/        # Type definitions
│   │   │   ├── utils/        # Utilities
│   │   │   └── page.tsx      # Page component
│   │   └── feature-b/  # Feature B
│   │       ├── __tests__/
│   │       ├── components/
│   │       ├── hooks/
│   │       ├── types/
│   │       ├── utils/
│   │       └── page.tsx
│   ├── (protected)/    # Protected routes
│   │   ├── components/ # Group-common components
│   │   ├── hooks/     # Group-common hooks
│   │   ├── types/     # Group-common type definitions
│   │   ├── utils/     # Group-common utilities
│   │   ├── layout.tsx # Group layout
│   │   ├── feature-c/ # Feature C
│   │   │   ├── components/
│   │   │   ├── hooks/
│   │   │   ├── types/
│   │   │   ├── utils/
│   │   │   └── page.tsx
│   │   └── feature-d/ # Feature D
│   │       ├── components/
│   │       ├── hooks/
│   │       ├── types/
│   │       ├── utils/
│   │       └── page.tsx
│   ├── layout.tsx      # Root layout
│   └── page.tsx        # Root page
├── components/         # Shared components
│   ├── features/       # Feature-specific components
│   ├── layout/        # Layout components
│   └── ui/            # Basic UI components
├── env/               # Environment variable definitions
└── lib/              # Shared logic
    ├── types/        # Global type definitions
    └── utils/        # Shared utilities
```

#### Basic Policy

1. Adopt Colocation Pattern
   - Group related files for each feature (page)
   - Place tests, components, hooks, and type definitions in the same directory
2. Route Grouping
   - Group related routes using parenthesized directories like `(public)`, `(protected)`
3. Place shared components in `src/components` directory
   - ui: Base components
   - features: Feature components
   - layout: Layout components

#### State Management Design

- Use Zustand, components access data via store
  - Manage with 1-store multi-slice pattern
  - Manage state per slice to improve reusability
- Implement hook functions as custom hooks

#### Architecture Document

Create `architecture.md` with the following structure:

1. System Overview

   - Architecture summary
   - Major components
   - Data flow

2. Tech Stack Details

   - Role of each technology
   - Version information
   - Dependencies

3. Component Design

   - Component hierarchy
   - Separation of concerns
   - State management strategy

4. Security Considerations

   - Authentication/Authorization
   - Data protection
   - Error handling

5. Performance Optimization

   - Rendering optimization
   - Data fetching strategy
   - Caching policy

6. Scalability

   - Future extensibility
   - Code reusability
   - Maintainability

7. Test Strategy
   - Types of tests
   - Test coverage
   - Test environment

### API Design Conventions

1. RESTful API Design Principles

   - Resource-oriented
   - Appropriate HTTP methods
   - Stateless

2. Endpoint Design

   - Consistent naming conventions
   - Versioning strategy
   - Error handling

3. Response Format

   - Unified JSON structure
   - Error response format
   - Status codes

4. Security
   - Authentication methods
   - Authorization control
   - Rate limiting
